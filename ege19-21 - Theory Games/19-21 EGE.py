#19-21
#19 номер делается вручную
#№1
'''За один ход игрок может добавить в одну из куч (по своему выбору) два
камня или увеличить количество камней в куче в два раза. Игра завершается в тот
момент, когда суммарное количество камней в кучах становится не менее 62.
Победителем считается игрок, сделавший последний ход, т.е. первым получивший
такую позицию, при которой в кучах будет 62 или больше камней. В начальный
момент в первой куче было 7 камней, во второй куче – S камней; 1 ≤ S ≤ 54.
Задание 19. 
Известно, что Ваня выиграл своим первым ходом после неудачного первого хода
Пети. Укажите минимальное значение S, когда такая ситуация возможна.
Задание 20.
Найдите минимальное значение S, при котором у Пети есть выигрышная стратегия,
причём одновременно выполняются два условия:
− Петя не может выиграть за один ход;
− Петя может выиграть своим вторым ходом независимо от того, как будет ходить
Ваня.
Задание 21
Найдите два значения S, при которых одновременно выполняются два условия:
– у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым
ходом при любой игре Пети;
– у Вани нет стратегии, которая позволит ему гарантированно выиграть первым
ходом. 
Найденные значения запишите в ответе в порядке возрастания.
'''
##from functools import lru_cache
##@lru_cache(None)
##def game(x,y):
##        if x + y >= 62:
##            return 0
##        tmp = [game(x+2,y), game(x,y+2), game(x*2,y), game(x,y*2)]##варианты(характеристики)
##        #если 0 то проигрыш, -1 то выигрывает второй
##        neg = []##отрицательные значения или ноль
##        for i in tmp:
##            if i <= 0:
##                neg.append(i)
##        if len(neg) != 0 : ## neg = [-1,-2,-1]
##                            ## взяли бы характеристики из neg
##                return -max(neg) + 1
##        else : 
##                ## tmp = [1,2,1,3]
##                return -max(tmp)##взяли бы характеристики из tmp
##
##for x in range(7,55):
##    r = game(7,x)
##    if r == 2:
##        print(x) ## Ответ на 20: 23,25,26
##for x in range(7,55):
##    r = game(7,x)
##    if r == -2:
##        print(x) ## Ответ на 21: 21,24

#№2
##from functools import lru_cache
##@lru_cache(None)
##def game(x,y):
##        if x + y >= 40:
##            return 0
##        tmp = [game(x+1,y), game(x,y+1), game(x*2,y), game(x,y*2)]##варианты(характеристики)
##        #если 0 то проигрыш, -1 то выигрывает второй
##        neg = []##отрицательные значения или ноль
##        for i in tmp:
##            if i <= 0:
##                neg.append(i)
##        if len(neg) != 0 : ## neg = [-1,-2,-1]
##                            ## взяли бы характеристики из neg
##                return -max(neg) + 1
##        else : 
##                ## tmp = [1,2,1,3]
##                return -max(tmp)##взяли бы характеристики из tmp
##
##for y in range(1,31):
##    r = game(9,y)
##    if r == 2:
##        print(x) ## Ответ на 20: 3 14
##for y in range(1,31):
##    r = game(9,y)
##    if r == -2:
##        print(y) ## Ответ на 21: 0(ничего не выводит)

#№3
'''
43)	(А. Кабанов) Два игрока, Петя и Ваня, играют в следующую игру.
Перед игроками лежит куча камней. Игроки ходят по очереди, первый ход делает
Петя. За один ход игрок может
а) добавить в кучу один камень;
б) добавить в кучу два камня;
в) добавить в кучу три камня;
г) увеличить количество камней в куче в два раза.
Игра завершается в тот момент, когда количество камней в куче превышает 33.
Победителем считается игрок, сделавший последний ход, то есть первым получивший
кучу, в которой будет 34 или больше камней. В начальный момент в куче было S
камней, 1 ≤ S ≤ 33.
Задание 19. 
Найдите значение S, при котором Ваня выигрывает своим первым ходом при любой
игре Пети?
Задание 20.
Найдите минимальное и максимальное значение S, при котором у Пети есть
выигрышная стратегия, причём одновременно выполняются два условия:
− Петя не может выиграть за один ход;
− Петя может выиграть своим вторым ходом независимо от того, как будет ходить
Ваня.
Найденные значения запишите в ответе в порядке возрастания.
Задание 21
Найдите значение S, при котором одновременно выполняются два условия:
– у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым
ходом при любой игре Пети;
– у Вани нет стратегии, которая позволит ему гарантированно выиграть первым
ходом.
'''
##from functools import lru_cache
##@lru_cache(None)
##def game(x):
##        if x >= 34:
##            return 0
##        tmp = [game(x+1), game(x+2), game(x+3), game(x*2)]##варианты(характеристики)
##        #если 0 то проигрыш, -1 то выигрывает второй
##        neg = []##отрицательные значения или ноль
##        for i in tmp:
##            if i <= 0:
##                neg.append(i)
##        if len(neg) != 0 : ## neg = [-1,-2,-1]
##                            ## взяли бы характеристики хода следующего игрока
##                return -max(neg) + 1
##        else : 
##                ## tmp = [1,2,1,3]
##                return -max(tmp)##взяли бы характеристики из tmp
##
####for x in range(1,34):
####    r = game(x)
####    if r == 2:
####        print(x) ## Ответ на 20: 8 13 14 15
##for x in range(1,34):
##    r = game(x)
##    if r == -2:
##        print(x) ## Ответ на 21: 12

#№4
'''
#из дз
#+1,+2,*3 >=62
from functools import lru_cache
@lru_cache(None)
def game(x):
        if x <= 30:
            return 0
        tmp = [game(x+1), game(x*2)]##варианты(характеристики)
        #если 0 то проигрыш, -1 то выигрывает второй
        neg = []##отрицательные значения или ноль
        for i in tmp:
            if i <= 0:
                neg.append(i)
        if len(neg) != 0 : ## neg = [-1,-2,-1]
                            ## взяли бы характеристики хода следующего игрока
                return -max(neg) + 1
        else : 
                ## tmp = [1,2,1,3]
                return -max(tmp)##взяли бы характеристики из tmp

for x in range(1,19):
    r = game(x)
    if r == -1:
        print(x) ## Ответ на 20: 8 13 14 15
##for x in range(1,61):
##    r = game(x)
##    if r == -2:
##        print(x) ## Ответ на 21: 17
'''

#№5
#из дз
'''
Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежат две кучи камней.
Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может добавить в одну из куч
один камень или увеличить количество камней в куче в два раза. Чтобы делать ходы, у каждого
игрока есть неограниченное количество камней. Игра завершается в тот момент, когда суммарное
количество камней в кучах становится не менее 53. Победителем считается игрок, сделавший
последний ход, т. е. первым получивший позицию, в которой в кучах будет 53 или больше камней.
В начальный момент в первой куче было 9 камней, во второй куче – S камней, 1 ≤ S ≤ 43. Будем
говорить, что игрок имеет выигрышную стратегию, если он может выиграть при любых ходах
противника.
Ответьте на следующие вопросы:
    Вопрос 1. Известно, что Ваня выиграл своим первым ходом после неудачного первого хода Пети.
                Назовите минимальное значение S, при котором это возможно.
    Вопрос 2. Найдите два таких значения S, при которых у Пети есть выигрышная стратегия, причём
                Петя не может выиграть первым ходом, но может выиграть своим вторым ходом независимо от того,
                как будет ходить Ваня. Найденные значения запишите в ответе в порядке возрастания.
    Вопрос 3. Сколько существует значений S, при которых у Вани есть выигрышная стратегия,
                позволяющая ему выиграть первым или вторым ходом при любой игре Пети, и при этом у Вани нет
                стратегии, которая позволит ему гарантированно выиграть первым ходом.
'''
##from functools import lru_cache
##@lru_cache(None)
##def game(x,y):
##        if x + y >= 53:
##            return 0
##        tmp = [game(x+1,y), game(x,y+1), game(x*2,y), game(x,y*2)]##варианты(характеристики)
##        #если 0 то проигрыш, -1 то выигрывает второй
##        neg = []##отрицательные значения или ноль
##        for i in tmp:
##            if i <= 0:
##                neg.append(i)
##        if len(neg) != 0 : ## neg = [-1,-2,-1]
##                            ## взяли бы характеристики из neg
##                return -max(neg) + 1
##        else : 
##                ## tmp = [1,2,1,3]
##                return -max(tmp)##взяли бы характеристики из tmp
##for x in range(1,44):
##    r = game(9,x)
##    if r == 2:
##        print(x) ## Ответ на 20: 23,25,26
##for x in range(1,44):
##    r = game(9,x)
##    if r == -2:
##        print(x) ## Ответ на 21: 21,24

#№6
'''
19, 20, 21 Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежат две кучи камней.
Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может добавить в одну из куч один
камень или увеличить количество камней в куче в два раза. Чтобы делать ходы, у каждого игрока есть
неограниченное количество камней. Игра завершается в тот момент, когда суммарное количество камней в
кучах становится не менее 69. Победителем считается игрок, сделавший последний ход, т. е. первым
получивший позицию, в которой в кучах будет 69 или больше камней.
В начальный момент в первой куче было 5 камней, во второй куче – S камней, 1 ≤ S ≤ 63. Будем говорить,
что игрок имеет выигрышную стратегию, если он может выиграть при любых ходах противника.
Ответьте на следующие вопросы:
 Вопрос 1. Известно, что Ваня выиграл своим первым ходом после неудачного первого хода Пети.
Назовите минимальное значение S, при котором это возможно.
 Вопрос 2. Найдите два таких значения S, при которых у Пети есть выигрышная стратегия, причём Петя не
может выиграть первым ходом, но может выиграть своим вторым ходом независимо от того, как будет
ходить Ваня. Найденные значения запишите в ответе в порядке возрастания.
 Вопрос 3. Укажите минимальное значение S, при котором у Вани есть выигрышная стратегия,
позволяющая ему выиграть первым или вторым ходом при любой игре Пети, и при этом у Вани нет
стратегии, которая позволит ему гарантированно выиграть первым ходом.

'''
##from functools import lru_cache
##@lru_cache(None)
##def game(x,y):
##    if x + y >= 69:
##        return 0
##    tmp = [game(x + 1, y), game(x*2,y), game(x,y+1), game(x,y*2)]
##    neg = []
##    for i in tmp:
##        if i<= 0:
##            neg.append(i)
##    if len(neg) != 0:
##        return -max(neg) + 1
##    else:
##        return -max(tmp)
#№1 - ручками! ответ: 16
#№2
##for i in range(1,64):
##    r = game(5,i)
##    if r == 2:
##        print(i)
#№3
##for i in range(1,64):
##    r = game(5,i)
##    if r == -2:
##        print(i)
##        break

#№7
'''
19, 20, 21 Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежит две
кучи камней. Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может
добавить в любую кучу один камень или увеличить количество камней в любой куче в
четыре раза. Игра завершается в тот момент, когда общее количество камней в двух кучах
становится не менее 95. Победителем считается игрок, сделавший последний ход. В
начальный момент в первой куче было 5 камней, а во второй – S камней, 1 ≤ S ≤ 89.
Ответьте на следующие вопросы:
 Вопрос 1. Известно, что Ваня выиграл своим первым ходом после неудачного первого хода
Пети. Назовите минимальное значение S, при котором это возможно.
 Вопрос 2. Найдите минимальное и максимальное значение S, при котором у Пети есть
выигрышная стратегия, причём одновременно выполняются два условия:
− Петя не может выиграть за один ход;
− Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня.
Найденные значения запишите в ответе в порядке возрастания.
 Вопрос 3. Найдите значение S, при котором одновременно выполняются два условия:
– у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом
при любой игре Пети;
– у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом.
'''
##from functools import lru_cache
##@lru_cache(None)
##def game(x,y):
##    if x + y >= 95:
##        return 0
##    tmp = [game(x+1,y), game(x * 4,y), game(x,y+1), game(x,y*4)]
##    neg = []
##    for i in tmp:
##        if i <= 0:
##            neg.append(i)
##    if len(neg) != 0:
##        return -max(neg) + 1
##    else:
##        return -max(tmp)
##for x in range(1,90):
##    r = game(5,x)
##    if r == -2:
##        print(x)

#№8
'''
Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежат две
кучи камней. Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может
добавить в одну из куч два камня или увеличить количество камней в куче в два раза.
Чтобы делать ходы, у каждого игрока есть неограниченное количество камней. Игра
завершается в тот момент, когда суммарное количество камней в кучах становится не менее
73. Победителем считается игрок, сделавший последний ход, т. е. первым получивший
позицию, в которой в кучах будет 73 или больше камней.
В начальный момент в первой куче было 9 камней, во второй куче – S камней, 1 ≤ S ≤ 63.
Будем говорить, что игрок имеет выигрышную стратегию, если он может выиграть при
любых ходах противника.
Ответьте на следующие вопросы:
 Вопрос 1. Известно, что Ваня выиграл своим первым ходом после неудачного первого хода ???????????????????????????? у меня ответ 18, а правильный 16
Пети. Назовите минимальное значение S, при котором это возможно.
 Вопрос 2. Укажите минимальное значение S, при котором у Пети есть выигрышная
стратегия, причём Петя не может выиграть первым ходом, но может выиграть своим вторым
ходом независимо от того, как будет ходить Ваня.
 Вопрос 3. Найдите два значения S, при которых у Вани есть выигрышная стратегия,
позволяющая ему выиграть первым или вторым ходом при любой игре Пети, и при этом у
Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом.
Найденные значения запишите в ответе в порядке возрастания.

'''
##from functools import lru_cache
##@lru_cache(None)
##def game(x,y):
##    if x + y >= 73:
##        return 0
##    tmp = [game(x+2,y), game(x*2,y), game(x,y+2), game(x,y*2)]
##    neg = []
##    for i in tmp:
##        if i <= 0:
##            neg.append(i)
##    if len(neg) != 0:
##        return -max(neg) + 1
##    else:
##        return -max(tmp)
##for i in range(1,64):
##    r = game(9,i)
##    if r == -2:
##        print(i)
##

#№9
#-----------------------------------------НЕТУ НЕУДАЧНОГО ХОДА----------------------------
''' НЕТУ НЕУДАЧНОГО ХОДА !!!
(Демо-2023) Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками
лежит куча камней. Игроки ходят по очереди, первый ход делает Петя. За один ход игрок
может добавить в кучу один камень или увеличить количество камней в куче в два раза. Для
того чтобы делать ходы, у каждого игрока есть неограниченное количество камней. Игра
завершается в тот момент, когда количество камней в куче становится не менее 129.
Победителем считается игрок, сделавший последний ход, т.е. первым получивший кучу из
129 или больше камней. В начальный момент в куче было S камней, 1 ≤ S ≤ 128.
Ответьте на следующие вопросы:
 Вопрос 1. Укажите такое значение S, при котором Петя не может выиграть за один ход, но
при любом ходе Пети Ваня может выиграть своим первым ходом.
 Вопрос 2. Найдите два наименьших значения S, при которых у Пети есть выигрышная
стратегия, причём Петя не может выиграть за один ход, но может выиграть своим вторым
ходом независимо от того, как будет ходить Ваня.
Найденные значения запишите в ответе в порядке возрастания.
 Вопрос 3. Найдите минимальное значение S, при котором Ваня может выиграть первым
или вторым ходом при любой игре Пети, но у него нет стратегии, которая позволит ему
гарантированно выиграть первым ходом. Если найдено несколько значений S, в ответе
запишите минимальное из них.

Идея:
Отвечая на первый вопрос, нужно получается найти ход ВАНИ (-1)
'''
##from functools import lru_cache
##@lru_cache(None)
##def game(x):
##    if x >= 129:
##        return 0
##    tmp = [game(x+1), game(x * 2)]
##    neg = []
##    for i in tmp:
##        if i <= 0:
##            neg.append(i)
##    if len(neg) != 0:
##        return -max(neg) + 1
##    else:
##        return -max(tmp)
##for i in range(1,129):
##    r = game(i)
##    if r == -1:
##        print(i)

#№10
'''
Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежит куча
камней. Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может
добавить в кучу один камень, добавить два камня или увеличить количество камней в куче в
два раза. При этом нельзя повторять ход, который только что сделал второй игрок.
Например, если в начале игры в куче 3 камня, Петя может первым ходом получить кучу из
4, 5 или 6 камней. Если Петя добавил 1 камень и получил кучу из 4 камней, то следующим
ходом Ваня может либо добавить 2 камня (и получить 6 камней), либо удвоить количество
камней в куче (их станет 8). Получить 5 камней Ваня не может, так как для этого нужно
добавить 1 камень, а такой ход только что сделал Петя.
Чтобы делать ходы, у каждого игрока есть неограниченное количество камней.
Игра завершается, когда количество камней в куче становится не менее 43. Победителем
счита-ется игрок, сделавший последний ход, то есть первым получивший кучу, в которой
будет 43 или больше камней. В начальный момент в куче было S камней, 1 ≤ S ≤ 42.
Ответьте на следующие вопросы:
 Вопрос 1. Укажите такое значение S, при котором Петя не может выиграть за один ход, но
при любом ходе Пети Ваня может выиграть своим первым ходом.
 Вопрос 2. Определите минимальное и максимальное значения S, при которых у Пети есть
выигрышная стратегия, причём одновременно выполняются два условия:
− Петя не может выиграть за один ход;
− Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня.
Найденные значения запишите в ответе в порядке возрастания.
 Вопрос 3. Найдите значение S, при котором одновременно выполняются два условия:
– у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом
при любой игре Пети;
– у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом.


Идея:
Отвечая на первый вопрос, нужно получается найти ход ВАНИ (-1)
Сложность:
Не понятно почему вопрос 2 - ответ 11,20 (у меня 19,20)
не понятно почему вопрос 3 - ответ 10 (у меня 18)
'''
##from functools import lru_cache
##@lru_cache(None)
##def game(x):
##    if x >= 43:
##        return 0
##    tmp = [game(x+1),game(x+2),game(x*2)]
##    neg = []
##    for i in tmp:
##        if i<=0:
##            neg.append(i)
##    if len(neg) != 0:
##        return -max(neg) + 1
##    else:
##        return -max(tmp)
##for i in range(1,43):
##    r = game(i)
##    if r == -2:
##        print(i)


#№11
'''
Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежат две
кучи камней. Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может
добавить в одну из куч один камень или увеличить количество камней в куче в три раза.
Чтобы делать ходы, у каждого игрока есть неограниченное количество камней. Игра
завершается в тот момент, когда суммарное количество камней в кучах становится не менее
45. Победителем считается игрок, сделавший последний ход, т. е. первым получивший
позицию, в которой в кучах будет 45 или больше камней.
В начальный момент в первой куче было 4 камня, во второй куче – S камней, 1 ≤ S ≤ 40.
Будем говорить, что игрок имеет выигрышную стратегию, если он может выиграть при
любых ходах противника.
Ответьте на следующие вопросы:
 Вопрос 1. Известно, что Ваня выиграл своим первым ходом после неудачного первого хода
Пети. Назовите минимальное значение S, при котором это возможно.
 Вопрос 2. Найдите два таких значения S, при которых у Пети есть выигрышная стратегия,
причём Петя не может выиграть первым ходом, но может выиграть своим вторым ходом
независимо от того, как будет ходить Ваня. Найденные значения запишите в ответе в
порядке возрастания.
 Вопрос 3. Укажите такое значение S, при котором у Вани есть выигрышная стратегия,
позволяющая ему выиграть первым или вторым ходом при любой игре Пети, и при этом у
Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом.

'''
##from functools import lru_cache
##@lru_cache(None)
##def game(x,y):
##    if x + y >= 45:
##        return 0
##    tmp = [game(x+1,y),game(x*3,y), game(x,y+1),game(x,y*3)]
##    neg = []
##    for i in tmp:
##        if i <= 0:
##            neg.append(i)
##    if len(neg) != 0:
##        return -max(neg) + 1
##    else:
##        return -max(tmp)
##for i in range(1,41):
##    r = game(4,i)
##    if r == -2:
##        print(i)

#№12 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
'''
Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежит две кучи камней. Игроки
ходят по очереди, первый ход делает Петя. За один ход игрок может добавить в любую кучу один камень или
добавить добавить в любую кучу столько камней, сколько их в данный момент в другой куче. Игра
завершается в тот момент, когда общее количество камней в двух кучах становится не менее 69. Победителем
считается игрок, сделавший последний ход. В начальный момент в первой куче было 7 камней, а во второй – S
камней, 1 ≤ S ≤ 61.
Ответьте на следующие вопросы:
Вопрос 1. Известно, что Ваня выиграл своим первым ходом после неудачного первого хода Пети. Назовите
минимальное значение S, при котором это возможно.
Вопрос 2. Найдите минимальное и максимальное значение S, при котором у Пети есть выигрышная стратегия,
причём одновременно выполняются два условия:
− Петя не может выиграть за один ход;
− Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня.
Найденные значения запишите в ответе в порядке возрастания.
Вопрос 3. Найдите значение S, при котором одновременно выполняются два условия:
– у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом при любой игре
Пети;
– у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом.

Идея: Постарайся писать важную инфу
Количество куч 2: Первая-> 7 Вторая-> 1<=S<=61
Победа: не менее 69
Ходы: +1 и ' или добавить добавить в любую кучу столько камней, сколько их в данный момент в другой куче'
# '''
# from functools import lru_cache
# @lru_cache(None)
# def game(x,y):
#     if x + y >= 69:
#         return 0
#     #Нужно выполнить условие, которое "или добавить добавить в любую кучу столько камней, сколько их в данный момент в другой куче"
#     tmp = [game(x+1,y), game(x,y+1), game(x+y,y), game(x,y+x)]
#     neg = [i for i in tmp if i <= 0]
#     if len(neg) != 0:
#         return -max(neg) + 1
#     else:
#         return -max(tmp)
# for i in range(7,62):
#     r = game(7,i)
#     if r == -2:
#         print(i)

#13 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
'''ДЖОБС
Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может
а) добавить в кучу сто камней или
б) увеличить количество камней в куче в два раза.
ВСЕГО ОДНА КУЧА: 1<= S <= 999
Игра завершается, если в куче становиться больше либо равно 1000 камней
Ответьте на следующие вопросы:
Вопрос 1. Сколько существует значений S, при которых Ваня выигрывает первым ходом?
Вопрос 2. Сколько существует значений S, при которых Петя может выиграть своим вторым ходом?
Вопрос 3. Назовите минимальное и максимальное значения S, при которых Ваня выигрывает своим первым
или вторым ходом, при этом для любого значения у Вани есть возможность выиграть своим первым ходом (в
случае ошибки Пети). Найденные значения запишите в ответе в порядке возрастания.
'''
# from functools import lru_cache
# @lru_cache(None)
# def game(x):
#     if x >= 1000:
#         return 0
#     tmp = [game(x+100),game(x*2)]
#     neg = [i for i in tmp if i <= 0]
#     if len(neg) != 0:
#         return -max(neg) + 1
#     else:
#         return -max(tmp)
# #Вопрос 1: 100
# c = 0
# for i in range(1,1000):
#     r = game(i)
#     if r == -1:
#         c+=1
# print('Вопрос 1:',c)
# #Вопрос 2: 150
# c = 0
# for i in range(1,1000):
#     r = game(i)
#     if r == 2:
#         c+=1
# print('Вопрос 2:',c)
# #Вопрос 3:
# w = []
# for i in range(1,1000):
#     r = game(i)
#     if r == -1 or r == -2:
#         w.append(i)
# print('Вопрос 3:', w[0], w[-1])

#14 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
'''
ХОД: +3, *2
Победа: Если будет больше 33
Всего куч : Одна куча
В начальный момент: 1<=s <= 32
Ответьте на следующие вопросы:
Вопрос 1. Найдите минимальное значение S, при котором Ваня выигрывает своим первым ходом при любой
игре Пети.
Вопрос 2. Сколько существует значений S, при которых у Пети есть выигрышная стратегия, причём
одновременно выполняются два условия:
 -Петя не может выиграть за один ход;
 -Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня.
Вопрос 3. Найдите два наибольших значения S, при которых одновременно выполняются два условия:
– у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом при любой игре
Пети;
– у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом.
Найденные значения запишите в ответе в порядке возрастания.
'''
# from functools import lru_cache
# @lru_cache(None)
# def game(x):
#     if x>= 33:
#         return 0
#     tmp = [game(x+3),game(x*2)]
#     neg = [i for i in tmp if i <= 0]
#     if len(neg) != 0:
#         return -max(neg) + 1
#     else:
#         return -max(tmp)
# #Вопрос 1: 14
# for i in range(1,33):
#     r = game(i)
#     if r == -1:
#         print('Вопрос 1:',i)
#         break
# #Вопрос 2: 5
# c = 0
# for i in range(1,33):
#     r = game(i)
#     if r == 2 :
#         c += 1
# print('Вопрос 2:',c)
# #Вопрос 3: 9 10
# for i in range(1,33):
#     r = game(i)
#     if r == -2:
#         print('Вопрос 3:', i)

#15 - - - -  - - - - - -- - - - - -- - - -  
""" Взято из сайта КЕГЭ номер задачи: 6608
Кучи: s>=13
Ходы: -12 или //3(количество камней, полученное при делении, округляется до меньшего)
Победа: <=12
Известо, что Ваня выиграл своим первым ходом после неудачного хода Пети.
При каком максимальном значении S такое возможно?
"""
# from functools import lru_cache
# @lru_cache(None)
# def game(x):
#     if x <= 12:
#         return 0
#     tmp = [game(x-12), game(x//3)]
#     neg = [i for i in tmp if i <= 0]
#     if len(neg) != 0:
#         return -max(neg) +1
#     else:
#         return -max(tmp)
#1) Нужно было 12 * 3 = 36, потом +2 = 38, затем 38*3=114, затем +2 = 116
# for i in range(13,1000):
#     r = game(i)
#     if r == 2:
#         print(i)
# for i in range(13,1001): #длина 24
#     r = game(i)
#     if r == -2:
#         print(i)


'''-----------------------------------------------------------------------------------------------------------------------'''
'''
    Раздел для интересных задач!
'''
#-------------------------------------------интересная задача---------------------
#№1
'''
 (А. Кабанов) Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежит две кучи
камней. Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может добавить в
любую кучу один камень или увеличить количество камней в любой куче в два раза. Игра
завершается в тот момент, когда суммарное количество камней в двух кучах становится не менее 30.
Победителем считается игрок, сделавший последний ход. В начальный момент в первой куче было K
камней, а во второй – S камней, 1 ≤ K ≤ 29, 1 ≤ S ≤ 29.
Ответьте на следующие вопросы:
Вопрос 1. Сколько существует пар (K; S), таких что Ваня выигрывает первым ходом при любой игре
Пети?
Вопрос 2. При K=6, найдите минимальное и максимальное значение S, при котором у Пети есть
выигрышная стратегия, причём одновременно выполняются два условия:
− Петя не может выиграть за один ход;
− Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня.
Найденные значения запишите в ответе в порядке возрастания.
Вопрос 3. Сколько существует пар (K; S), при котором одновременно выполняются два условия:
– у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом при
любой игре Пети;
– у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом.
'''
##from functools import lru_cache
##@lru_cache(None)
##def game(x,y):
##    if x + y >= 30:
##        return 0
##    tmp = [game(x+1,y), game(x*2,y), game(x,y+1), game(x,y*2)]
##    neg = []
##    for i in tmp:
##        if i <= 0 :
##            neg.append(i)
##    if len(neg) != 0:
##        return -max(neg) + 1
##    else:
##        return -max(tmp)
###1
##w = []
##for K in range(1,31):
##    for S in range(1,31):
##        r = game(K,S)
##        if r == -1:
##            w.append((K,S)) 
##print(len(w))
###2
##w1 = []
##for K in range(1,31):
##    for S in range(1,31):
##        r = game(K,S)
##        if r == 2 and K == 6:
##            w1.append((K,S))
##print(w1)
###3
##w3 = []
##for K in range(1,31):
##    for S in range(1,31):
##        r = game(K,S)
##        if r == -2:
##            w3.append((K,S))
##print(len(w3))

#№2 Вычитания
'''Кабанов
Кол-во куч: две кучи; Первая: 10 Вторая: s > 22
Ходы:-1 или %2((если количество камней в куче нечётно, остаётся на 1 камень больше, чем убирается).)
Победа: Если <=32

Ответьте на следующие вопросы:
Вопрос 1. Найдите значение S, при котором Ваня выигрывает своим первым ходом при любой игре Пети.
Вопрос 2. Найдите минимальное и максимальное значение S, при котором у Пети есть выигрышная стратегия,
причём одновременно выполняются два условия:
- Петя не может выиграть за один ход;
- Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня.
Найденные значения запишите в ответе в порядке возрастания.
Вопрос 3. Найдите значение S, при котором одновременно выполняются два условия:
– у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом при любой игре
Пети;
– у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом.
'''
# from functools import lru_cache
# @lru_cache(None)
# def game(x,y):
#     if x + y <= 32:
#         return 0
#     tmp = []
#     if x - 1 > 0:
#         tmp.append(game(x - 1,y))
#     if y - 1 > 0:
#         tmp.append(game(x, y - 1))
#     if x > 1:
#         if x % 2 != 0: #В зависимости от вопроса нужно ли +1 или -1
#             tmp.append(game((x+1)/2,y))
#         else:
#             tmp.append(game(x/2,y))
#     if y > 1:
#         if y % 2 != 0 :
#             tmp.append(game(x,(y+1)/2))
#         else:
#             tmp.append(game(x,y/2))
#     neg = [i for i in tmp if i <= 0]
#     if len(neg) != 0 :
#         return -max(neg) + 1
#     else:
#         return -max(tmp)
##Вопрос 1: 45 (maybe)
# for i in range(23,101):
#     r = game(10,i)
#     if r == -1 :
#         print('Ответ на 1 вопрос :',i)
##Вопрос 2: (maybe) 46 and 90
# for i in range(23,101): 
#     r = game(10,i)
#     if r == 2:
#         print('Ответ на 2 вопрос :',i)
##Вопрос 3: 48 (maybe)
# for i in range(23,101):
#     r = game(10,i)
#     if r == -2:
#         print('Ответ на 3 вопрос :',i)

#№3
'''
Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежит две кучи камней. Игроки
ходят по очереди, первый ход делает Петя. За один ход игрок может добавить в любую кучу один камень или
добавить добавить в любую кучу столько камней, сколько их в данный момент в другой куче. Игра
завершается в тот момент, когда общее количество камней в двух кучах становится не менее 69. Победителем
считается игрок, сделавший последний ход. В начальный момент в первой куче было 7 камней, а во второй – S
камней, 1 ≤ S ≤ 61.
Ответьте на следующие вопросы:
Вопрос 1. Известно, что Ваня выиграл своим первым ходом после неудачного первого хода Пети. Назовите
минимальное значение S, при котором это возможно.
Вопрос 2. Найдите минимальное и максимальное значение S, при котором у Пети есть выигрышная стратегия,
причём одновременно выполняются два условия:
− Петя не может выиграть за один ход;
− Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня.
Найденные значения запишите в ответе в порядке возрастания.
Вопрос 3. Найдите значение S, при котором одновременно выполняются два условия:
– у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом при любой игре
Пети;
– у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом.

Идея: Постарайся писать важную инфу
Количество куч 2: Первая-> 7 Вторая-> 1<=S<=61
Победа: не менее 69
Ходы: +1 и ' или добавить добавить в любую кучу столько камней, сколько их в данный момент в другой куче'
# '''
# from functools import lru_cache
# @lru_cache(None)
# def game(x,y):
#     if x + y >= 69:
#         return 0
#     #Нужно выполнить условие, которое "или добавить добавить в любую кучу столько камней, сколько их в данный момент в другой куче"
#     tmp = [game(x+1,y), game(x,y+1), game(x+y,y), game(x,y+x)]
#     neg = [i for i in tmp if i <= 0]
#     if len(neg) != 0:
#         return -max(neg) + 1
#     else:
#         return -max(tmp)
# for i in range(7,62):
#     r = game(7,i)
#     if r == -2:
#         print(i)

#4
"""
Номер задания КЕГЭ №6608
Кучи: s>=13
Ходы: -12 или //3(количество камней, полученное при делении, округляется до меньшего)
Победа: <=12
Известо, что Ваня выиграл своим первым ходом после неудачного хода Пети.
При каком максимальном значении S такое возможно?
"""
# from functools import lru_cache
# @lru_cache(None)
# def game(x):
#     if x <= 12:
#         return 0
#     tmp = [game(x-12), game(x//3)]
#     neg = [i for i in tmp if i <= 0]
#     if len(neg) != 0:
#         return -max(neg) +1
#     else:
#         return -max(tmp)

# 1 вопрос: Нужно было 12 * 3 = 36, потом +2 = 38, затем 38*3=114, затем +2 = 116
# 2 вопрос:
# for i in range(13,1000):
#     r = game(i)
#     if r == 2:
#         print(i)
# 3 вопрос:
# for i in range(13,1001): #длина 24
#     r = game(i)
#     if r == -2:
#         print(i)