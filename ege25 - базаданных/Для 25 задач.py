#Функция,которая проверяет на простые числа:
def is_Prime(x):
    if x < 2:
        return False
    i = 2
    while i * i <= x:
        if x % i == 0:
            return False
        i+=1
    return True
#Функция, которая показывает какие есть делители у числа
def dels(x):
    a = []
    i = 1
    while i**2 <= x:
        if i**2 == x:
            a.append(i)
        elif x % i == 0:
            a += [i, x // i]
        i += 1
    a.sort()
    return a
#искать делители, при условии если маленький отрезок!
def f(x):
    c = 0
    for i in range(1, x+1):
        if x % i == 0:
            c+=1
    return x

''' ТЕОРИЯ
    Для того, чтобы работать с интервалами чисел нужно понимать, как работают функции:
    1)Проверка делителей
    2)Проверка на простое число

    ТЕОРИЯ:
1) Простое число - это натуральные числа, которое имеет два делителя (1 и само на себя), при этом собственные делители у него, это только ЕДИНИЦА,
СОСТВЕННЫЕ ДЕЛИТЕЛИ, ОТЛИЧНЫЕ ОТ САМОГО ПРОСТОГО ЧИСЛА
2) Составные числа - натуральные числа, которые имеют несколько делителей(больше 1)
ВАЖНО: 1(единица) - НЕ ПРОСТОЕ ЧИСЛО И НЕ СОСТАВНОЕ ЧИСЛО!!!!
3) Тривиальные делители - это делители 1 и самого числа
4) Нетривиальные делители - это НЕ делители 1-цы и самого числа

    Используй :
    list.remove(определенное значение)
'''

'''
    Этот раздел предназначен для примеров
'''
#1
'''
(К. Амеличев) Среди целых чисел, принадлежащих числовому отрезку [1060; 18813], найдите числа, которые
являются простыми. Ответом будет сумма найденных чисел.
'''
# w = []
# for i in range(1060,18814):
#     if is_Prime(i) == True:
#         w.append(i)
# print(sum(w))

#2
'''
(Д.Ф. Муфаззалов) Число называется избыточным, если оно меньше суммы своих собственных
делителей (то есть всех положительных делителей, отличных от самого? числа). Определите
количество избыточных чисел из диапазона [2; 20000].
'''
# def f(x):
#    a = []
#    i = 1
#    while i**2 <= x:
#        if i**2 == x:
#            a.append(i)
#        elif x % i == 0:
#            a = a + [i, x // i] # [i, x // i]
#        i += 1
#    a.sort()
#    return a
# c=0
# print(f(150)) #[1, 2, 3, 5, 6, 10, 15, 25, 30, 50, 75, 150], не берется последний элемент
# print(f(20000)) #[1, 2, 4, 5, 8, 10, 16, 20, 25, 32, 40, 50, 80, 100, 125, 160, 200, 250, 400, 500, 625, 800, 1000, 1250, 2000, 2500, 4000, 5000, 10000, 20000], не берется последний элемент
# #Петров Влад молодец
# for i in range(2,20001):
#    if i < sum(f(i)[:-1]) : c+=1
# print(f"количество таких значенией отличных от самого себя: {c}")

# for i in range(2,20001):
#    c = 0
#    s = f(i)
#    #c = len([i for i in s]) #Количество делителей
#    sm = sum([i for i in s]) #Сумма делителей - каждого
#    if i < sm :
#        c +=1
# print(c)

#3
'''
Напишите программу, которая ищет среди целых чисел, принадлежащих числовому отрезку [100806; 100950], числа, имеющие ровно 6 различных делителей.
Выведите эти делители для каждого найденного числа в порядке возрастания.
'''
#ПРОВЕРКА НА ДЕЛИТЕЛИ
##def f(x):
##    a = []
##    i = 1
##    while i**2 <= x:
##        if i**2 == x:
##            a.append(i)
##        elif x % i == 0:
##            a += [i, x // i]
##        i += 1
##    a.sort()
##    return a
##
##for i in range(100806, 100951):
##    a = f(i)
##    if len(a) == 6:
##        print(*a)

#4
''' Номер с Полякова: 42
Напишите программу, которая ищет среди целых чисел, принадлежащих числовому отрезку [4202865; 4202923], простые числа.
Выведите все найденные простые числа в порядке возрастания, слева от каждого числа выведите его номер по порядку.
'''
##def prime(x):
##    if x < 2:
##        return False
##    i = 2
##    while i**2 < x:
##        if x % i == 0:
##            return False
##        i += 1
##    return True
##c = 0
##for i in range(4202865, 4202924):
##    if prime(i):
##        c += 1
##        print(c, i)

#5
''' Номер с Полякова: 70
(Д.Ф. Муфаззалов, г. Уфа)
Совершенным называется число, натуральное число, равное сумме всех своих
собственных делителей (то есть всех положительных делителей, отличных от самого́ числа) (например, число 6=1+2+3). 
Выведите каждое совершенное число из диапазона [2; 10000] и количество его собственных делителей в порядке возрастания.
Вывод каждого совершенного числа начинайте с новой строки.
Числа в строке разделяйте пробелом.
'''
##def dels(x):
##    a = []
##    i = 1
##    while i**2 <= x:
##        if i**2 == x:
##            a.append(i)
##        elif x % i == 0:
##            a += [i, x // i]
##        i += 1
##    a.sort()
##    return a
##res = {}
##for i in range(2, 10001):
##    dl = dels(i)[:-1] #(НЕ СМОТРЕТЬ НА САМОГО СЕБЯ)
##    if i == sum(dl):
##        res[len(dl)] = i
##for key in sorted(res.keys()):
##    print(res[key], key)

#6
''' Номер с Полякова 84
(С.А. Скопинцева) Cреди целых чисел, принадлежащих числовому отрезку [87921; 88187], найдите числа, сумма цифр которых кратна 14,
а произведение цифр кратно 18 и не равно 0.
Для каждого найденного числа запишите сумму и произведение его цифр в таблицу на экране с новой строки в порядке возрастания произведения цифр.
'''
# res = {}
# for i in range(87921, 88188):
#     sm = sum(map(int, str(i)))
#     pr = reduce(lambda a, b: a*b, map(int,  str(i)))
#     if not(sm % 14) and not(pr % 18) and pr != 0:
#         res[pr] = sm
# for key in sorted(res.keys()):
#     print(res[key], key)

#7
'''
31) Напишите программу, которая ищет среди целых чисел, принадлежащих числовому отрезку [1820348; 2880927],
числа, имеющие ровно 5 различных делителей.
Выведите эти делители для каждого найденного числа в порядке возрастания.
'''
##def prime(x):
##    if x < 2:
##        return False
##    i = 2
##    while i**2 < x:
##        if x % i == 0:
##            return False
##        i += 1
##    return True
###так как чтобы не долго высчитывало все
##for i in range(1,1000):
##    if prime(i) and i ** 4 in range(1820348,2880928):
##        print(1,i,i**2,i**3,i**4) # не понятно как догадались до этого?
###Только в простом числе в 4 степени имеет 5 делителей

#8
'''
127)Назовём нетривиальным делителем натурального числа его делитель, не равный единице и самому числу.
Найдите все натуральные числа, принадлежащие отрезку [1523467; 4157812] и имеющие ровно три нетривиальных делителя.
Для каждого найденного числа запишите в ответе само число и его наибольший нетривиальный делитель.
Найденные числа расположите в порядке возрастания.
'''
##for i in range(1,1000):
##    if prime(i) and i**4 in range(1523467, 4157813): # будут включатся число на 1 и на себя, но
##        print(i**2,i**3)#здесь мы его исключаем , просто пишем второе и третье (делители, 1 , i, i**2,i**3,i**4)

#9
'''
(П.Е. Финкель) Уникальным назовём число, если у него только третья и пятая цифры чётные. Для интервала
[33333;55555] найдите количество таких чисел, которые не делятся на 6, 7, 8 и разность максимального и
минимального из них. В ответе укажите два числа:сначала количество чисел, а потом разность.
'''
# count = 0
# mx = -10**10
# mn = 10**10 
# for i in range(33333,55556):
#     ch1 = str(i)[2]
#     ch2 = str(i)[-1]
#     # - - - - -  - - - 
#     ch3 = str(i)[0]
#     ch4 = str(i)[1]
#     ch5 = str(i)[3]
#     if int(ch1) % 2 == 0 and int(ch2) % 2 == 0 and int(ch3) % 2 != 0 and int(ch4) % 2 != 0 and int(ch5) % 2 != 0:
#         # print(i,ch1,ch2)
#        if i % 6 != 0 and i % 7 != 0 and i % 8 != 0:
#             count += 1
#             mx = max(mx,i)
#             mn = min(mn,i)
# print(count, mx-mn)

#10
'''
Напишите программу, которая ищет среди целых чисел, принадлежащих числовому отрезку [11275; 16328],
числа, имеющие ровно 5 различных делителей. В ответе для каждого найденного числа запишите два его
наибольших делителя, не равных самому числу, в порядке возрастания
'''
# from functools import lru_cache
# def dels(x):
#     a = []
#     i = 1
#     while i**2 <= x:
#         if i**2 == x:
#             a.append(i)
#         elif x % i == 0:
#             a += [i, x // i]
#         i += 1
#     a.sort()
#     return a
# a = []
# for i in range(11275, 16329):
#     if len(dels(i)) == 5:
#         a.append(dels(i))
# print(a)

#11
'''
Напишите программу, которая ищет среди целых чисел, принадлежащих числовому отрезку [20789; 35672],
числа, имеющие ровно 5 различных делителей. Выведите количество таких чисел и наименьшее их них.
'''
# def dels(number):
#     a = []
#     i = 1
#     while i ** 2 <= number:
#         if i ** 2 == number:
#             a.append(i)
#         elif number % i == 0:
#             a += [i, number//i]
#         i += 1
#     a.sort()
#     return a
# c = 0
# mn = 10**10
# for i in range(20789, 35673):
#     if len(dels(i)) == 5:
#         c+=1
#         mn = min(mn,i)
# print(c,mn)

#12
''' #22
Напишите программу, которая ищет среди целых чисел, принадлежащих числовому отрезку [190201; 190280], числа, имеющие ровно 4 различных ЧЁТНЫХ делителя.
Выведите эти четыре делителя для каждого найденного числа в порядке убывания.
'''
##for i in range(190201,190281):
##    d = dels(i)
##    du = [j for j in d if j % 2 == 0] #перебираем элементы и проверяем их на чётность
##    if len(du) == 4:
##        print(*du[::-1])
#13
'''33)(Б.С. Михлин)
Напишите программу, которая ищет среди целых чисел, принадлежащих числовому отрезку [286564; 287270], числа, имеющие максимальное количество различных делителей.
Если таких чисел несколько, то найдите максимальное из них.
Выведите количество делителей найденного числа и два наибольших делителя в порядке убывания
'''

# res = []
# for i in range(286564, 287271):
#     d = dels(i) #Возвращает список
#     res.append([len(d), d])
# res.sort(key=lambda x: x[0], reverse=True)
# print(res[0][0]) #Выводит количество делителей
# print(*sorted(res[0][1]))# выводит делители
# print(*sorted(res[0][1], reverse=True)[:2])
##print(res[0][0], *sorted(res[0][1], reverse=True)[:2])

#14
''' Номер с Полякова 69
Уникальным назовём число, если у него только последние три цифры нечётные.
Для интервала [64444;77563] найдите количество таких чисел, которые не делятся на 9, 13, 17,  и разность максимального и минимального из них.
В ответе укажите два числа: сначала количество чисел, а потом разность.

Идея:
1)Сказано,что последние три цифры нечётные, то остальная часть должна быть чётная (сделать аналогию с кошелком, где есть купюры)
'''
##def f(x):
##    #Проверяет первый элемент (с конца)
##    if (x % 10) % 2 == 0:
##        return False
##    #проверяет второй элемент (с конца)
##    elif ((x // 10) %10) % 2 == 0:
##        return False
##    #проверяет третий элемент (с конца)
##    elif ((x // 100) %10) % 2 ==0:
##        return False
##    #проверяет 4 элемент и 5 элемент (с конца)
##    elif ((x // 1000) %10) % 2 ==0 and ((x // 10000) %10) % 2 ==0:
##        return True
##    else:
##        return False
##mx = -10**10
##mn = 10**10
##c = 0
##w = []
##for i in range(64444,77564):
##    if f(i) == True and (i % 9 != 0) and (i % 13 != 0) and (i % 17 != 0):
##        c+=1
##        mx = max(mx,i)
##        mn = min(mn,i)
##print(c, mx - mn)

#15
''' Смотри из Полякова
*(Д. Статный) Среди натуральных чисел, принадлежащих отрезку [35 000 000; 100 000 000], найдите все
числа, имеющие ровно 5 нечётных делителей (количество чётных делителей неважно). В ответ запишите первые
5 таких чисел числа в порядке возрастания, справа от каждого числа запишите его максимальный нечётный
делитель.
'''
# f = c = 0
# mx = -10**10
# w = []
# for i in range(50,100):
#     w.append(dels(i)) 
    # f = dels(i) #Делители в списке
    # for j in w:
    #     mx = max(i for i in j if i % 2 != 0)
    # for j in f: 
    #     if j % 2 != 0: #Перебор делителей в списке по условию, что они нечётные 
            
    #         mx = max(mx, j)
    #     else:
    #         pass
    # print(i,f,mx)
    #         # print(i,mx)

'''
Этот раздел предназначен для трудных примеров
'''
#1
'''
Обозначим через P(N) – произведение 5 наименьших различных нетривиальных делителей натурального числа N (не считая единицы и самого числа). 
Если у числа N меньше 5 таких делителей, то P(N) считается равным нулю. 
Найдите 5 наименьших натуральных чисел, превышающих 300 000 000, для которых P(N) оканчивается на 31 и не превышает N. 
В ответе для каждого найденного числа запишите сначала значение P(N), а затем – наибольший делитель, вошедший в произведение P(N).

Идея: Что такое нетривиальные делители: всякий делитель числа, но отличающийся от самого числа!!!
К примеру у простого числа 3: есть два делителя 1 и 3, поэтому 1 - это тривиальный делитель

1)Составить функцию по поиску делителей
2)Сделать условие
'''
# p = 0
# for i in range(1,300000):
#     # p = dels(i[1]) * dels(i[2]) * dels(i[3]) * dels(i[4])* dels(i[5]) 
#     p = dels(i)
#     # print(p[1])
#     if len(p[1:6]) < 5 :
#         p = 0
#         continue
#     p1 = p[1] * p[2] * p[3] * p[4] *p[5] 
#     if p1 % 100 == 31 and p1 < i and p[1] > 300000000 and p[2] > 300000000  and p[3] > 300000000  and p[4] > 300000000  and p[5] > 300000000 :
#         print(i,p[1:6],p1)

# for i in range(10,20,2):
#     a = dels(i)
#     print(a,a[1],a[2])

# a = [12,1,21,4,1,2,4]
# b = a[1:6]
# print((a[1])*a[2])
# print(len(b))

#2
''' Номер с Полякова 71
Определите количество составных натуральных чисел из диапазона [2; 20000], у которых количество простых собственных делителей больше трех.

ТЕОРИЯ:
1) Простое число - это натуральные числа, которое имеет два делителя (1 и само на себя), при этом собственные делители у него, это только ЕДИНИЦА,
СОСТВЕННЫЕ ДЕЛИТЕЛИ, ОТЛИЧНЫЕ ОТ САМОГО ПРОСТОГО ЧИСЛА
2) Составные числа - натуральные числа, которые имеют несколько делителей(больше 1)
ВАЖНО: 1(единица) - НЕ ПРОСТОЕ ЧИСЛО И НЕ СОСТАВНОЕ ЧИСЛО!!!!
3) Тривиальные делители - это делители 1 и самого числа

ИДЕЯ:
1)Перебрать промежуток [2, 20000], каждое число проверить, что оно имеет несколько делителей
2)Количество делителей должно быть больше 3
'''
##c = 0 #17703
##g = 0 #Проверяет 
##for i in range(2, 20001):
##    if len(dels(i)) > 2:
##        s = dels(i) #[1, 2, 4]? [1, 2, 3, 6]
##        print(s)
##for j in s: